"""
  Given a set of rules, I can determine if a string of a's and b's matches specific rules. 
  This is done by expanding the rule with its subrules recursively until end position are reached,
  possibly generating multiple valid strings. 
"""

import sys, re
from copy import deepcopy
import functools

# Read input by parsing rules and strings
def read_input(input):
  rules = {}
  for line in map(str.rstrip, input):
    if not line:
      break

    rule_number, options = line.split(": ")
    rule_number = int(rule_number)

    if '"' in options: 
      rule = options.strip('"')

    else: 
      rule = []
      for o in options.split("|"):
        rule.append(tuple(map(int, o.split())))

    rules[rule_number] = rule        
  
  return rules

# Define the set of valid strings generated by expanding rule 0
# Each subrule produces a list of valid strings 
def build_regexp(rules, rule_number=0):
  rule = rules[rule_number]
  if type(rule) is str:
    return rule
  
  options = []
  for option in rule:
    option = ''.join(build_regexp(rules, sub_rule) for sub_rule in option)
    options.append(option)

  return '(' + '|'.join(options) + ')'

def build_regexp_special(rules, rule_number=0):

  if rule_number == 8:
    option = ''.join(build_regexp_special(rules, 42))
    return '(' + option + ')+'

  if rule_number == 11:
    a = ''.join(build_regexp_special(rules, 42))
    b = ''.join(build_regexp_special(rules, 31))
    options = []
    for n in range(1, 51):
      options.append("{a}{{{n}}}{b}{{{n}}}".format(a=a, b=b, n=n))
    return '(' + '|'.join(options) + ')'

  rule = rules[rule_number]
  if type(rule) is str:
    return rule
  
  options = []
  for option in rule:
    option = ''.join(build_regexp_special(rules, sub_rule) for sub_rule in option)
    options.append(option)

  return '(' + '|'.join(options) + ')'

# Find the intersection between valid and input string.  


def main():
  fin = open(sys.argv[1])
  rules = read_input(fin)
  
  regexp1 = re.compile('^' +build_regexp(rules) + '$')
  regexp2 = re.compile('^' +build_regexp_special(rules) + '$')

  valid_count1 = 0
  valid_count2 = 0

  for s in map(str.rstrip, fin):
    if regexp1.match(s): 
      valid_count1 += 1
    if regexp2.match(s):
      valid_count2 += 1
    
  print("Part 1: ", valid_count1)
  print("Part 2: ", valid_count2)

main()